# -*- coding: utf-8 -*-
"""sat_decision.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fhTUZKu_ozmVCFIwNuI1AJO2qyyUNmvF
"""

#!pip install z3-solver --quiet
from z3 import *
import os
import time
import sys
import json

def ensure_folders():
    if not os.path.exists("res"):
        os.makedirs("res")
    if not os.path.exists("res/SAT"):
        os.makedirs("res/SAT")

def write_json(path, time_val, optimal, obj, sol):
    data = {
        "time": time_val,
        "optimal": optimal,
        "obj": obj,
        "sol": sol
    }
    with open(path, "w") as f:
        json.dump(data, f, indent=4)

def exactly(k, vars):
    return PbEq([(v,1) for v in vars], k)

def at_most(k, vars):
    return PbLe([(v,1) for v in vars], k)

def create_vars(n):
    W = n - 1
    P = n // 2

    play = {(i,j,w): Bool(f"play_{i}_{j}_{w}")
            for i in range(n) for j in range(n) if i != j
            for w in range(W)}

    home = {(i,j,w): Bool(f"home_{i}_{j}_{w}")
            for i in range(n) for j in range(n) if i != j
            for w in range(W)}

    per  = {(i,w,p): Bool(f"per_{i}_{w}_{p}")
            for i in range(n) for w in range(W) for p in range(P)}

    return play, home, per

def extract_schedule(model, n, play, home, per):
    W = n - 1
    P = n // 2
    sched = [[None for _ in range(W)] for _ in range(P)]

    for w in range(W):
        for p in range(P):

            teams = [t for t in range(n)
                     if model.evaluate(per[(t,w,p)], model_completion=True)]

            if len(teams) != 2:
                sched[p][w] = [None, None]
                continue

            i, j = teams
            if model.evaluate(home[(i,j,w)], model_completion=True):
                sched[p][w] = [i, j]
            else:
                sched[p][w] = [j, i]

    return sched

#HARD CONSTRAINTS

def add_hard_constraints(s, n, play, home, per):
    W = n - 1
    P = n // 2

    # Each pair plays exactly once
    for i in range(n):
        for j in range(i+1, n):
            s.add(exactly(1,
                [play[(i,j,w)] for w in range(W)] +
                [play[(j,i,w)] for w in range(W)]
            ))

    # Each team plays exactly once per week
    for i in range(n):
        for w in range(W):
            s.add(exactly(1,
                [play[(i,j,w)] for j in range(n) if j != i] +
                [play[(j,i,w)] for j in range(n) if j != i]
            ))

    # Each team assigned to exactly one period per week
    for i in range(n):
        for w in range(W):
            s.add(exactly(1, [per[(i,w,p)] for p in range(P)]))

    # Each period holds exactly one match => exactly 2 teams
    for w in range(W):
        for p in range(P):
            s.add(exactly(2, [per[(i,w,p)] for i in range(n)]))

#CHANNELING CONSTRAINTS

def add_channeling_constraints(s, n, play, home, per):
    W = n - 1
    P = n // 2

    for i in range(n):
        for j in range(n):
            if i == j: continue
            for w in range(W):

                # home(i,j,w) → play(i,j,w)
                s.add(Implies(home[(i,j,w)], play[(i,j,w)]))

                # play(i,j,w) ↔ (home(i,j,w) XOR home(j,i,w))
                s.add(Implies(play[(i,j,w)],
                              Or(home[(i,j,w)], home[(j,i,w)])))
                s.add(Implies(play[(i,j,w)],
                              Not(And(home[(i,j,w)], home[(j,i,w)]))))

                # If play(i,j,w) → they share a period
                s.add(Implies(
                    play[(i,j,w)],
                    Or([And(per[(i,w,p)], per[(j,w,p)]) for p in range(P)])
                ))

#IMPLIED CONSTRAINTS

def add_implied_constraints(s, n, play, home, per):
    W = n - 1

    # Simple anti-symmetry: no redundant back-edges
    for i in range(n):
        for j in range(i):
            for w in range(W):
                # Prevent mirrored duplicate: if i<j, forbid home(j,i,w) without play
                s.add(Implies(home[(j,i,w)], play[(j,i,w)]))

    # If play(i,j,w), cannot play any other match same week
    for i in range(n):
        for w in range(W):
            others = [play[(i,k,w)] for k in range(n) if k!=i] + \
                     [play[(k,i,w)] for k in range(n) if k!=i]
            # Already enforced by hard constraints, but adding XOR tightening:
            for (a,b) in zip(others, others[1:]):
                s.add(Or(Not(a), Not(b)))

    # period-device strengthening: if i in period p and j in period p, they must play
    # (logical tightening: removes impossible period placements)
    for i in range(n):
        for j in range(n):
            if i == j: continue
            for w in range(W):
                for p in range(n//2):
                    s.add(Implies(
                        And(per[(i,w,p)], per[(j,w,p)]),
                        Or(play[(i,j,w)], play[(j,i,w)])
                    ))

#SYMMETRY BREAKING CONSTRAINTS

def add_symmetry_constraints(s, n, play, home):
    # Fix first match: 0 plays 1 in week 0, 0 at home
    s.add(play[(0,1,0)])
    s.add(home[(0,1,0)])

    # Prevent trivial swapping of team numbers:
    # Force team 0 to play the lowest-index opponent first
    for j in range(2, n):
        # 0 cannot play j in week 0
        s.add(Not(play[(0,j,0)]))

#SOLVE

def solve_decision_instance(n):
    ensure_folders()

    play, home, per = create_vars(n)
    s = Solver()
    s.set("timeout", 300000)
    s.set("threads", 1)

    add_hard_constraints(s, n, play, home, per)
    add_channeling_constraints(s, n, play, home, per)
    add_implied_constraints(s, n, play, home, per)
    add_symmetry_constraints(s, n, play, home)

    start = time.time()
    res = s.check()
    elapsed = time.time() - start

    if str(res) != "sat":
        write_json(f"res/SAT/{n}.json", 300, False, None, None)
        return

    model = s.model()
    schedule = extract_schedule(model, n, play, home, per)
    t_out = int(elapsed) if elapsed < 300 else 300

    write_json(f"res/SAT/{n}.json", t_out, True, None, schedule)

#MAIN

if __name__ == "__main__":

    if len(sys.argv) == 2 and sys.argv[1].isdigit():
        solve_decision_instance(int(sys.argv[1]))
    else:
        values = [4,6,8,10,12,14,16,18]
        print("Running batch decision solver on:", values)
        for n in values:
            print(f"Solving n={n} ...")
            solve_decision_instance(n)
            print(f"Saved res/SAT/{n}.json")
        print("Batch complete.")