# -*- coding: utf-8 -*-
"""sat_opt.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hCg5UFWeIZKw3xquzC6hAZylJWRhYZda
"""

!pip install z3-solver --quiet
from z3 import *
import os
import time
import sys
import json

def ensure_folders():
    if not os.path.exists("res"):
        os.makedirs("res")
    if not os.path.exists("res/SAT"):
        os.makedirs("res/SAT")

def write_json(path, time_val, optimal, obj, sol):
    with open(path, "w") as f:
        json.dump({
            "time": time_val,
            "optimal": optimal,
            "obj": obj,
            "sol": sol
        }, f, indent=4)

def exactly(k, vars):
    return PbEq([(v,1) for v in vars], k)

def at_most(k, vars):
    return PbLe([(v,1) for v in vars], k)

def create_vars(n):
    W = n - 1
    P = n // 2

    play = {(i,j,w): Bool(f"play_{i}_{j}_{w}")
            for i in range(n) for j in range(n)
            if i != j for w in range(W)}

    home = {(i,j,w): Bool(f"home_{i}_{j}_{w}")
            for i in range(n) for j in range(n)
            if i != j for w in range(W)}

    per  = {(i,w,p): Bool(f"per_{i}_{w}_{p}")
            for i in range(n) for w in range(W) for p in range(P)}

    return play, home, per

def extract_schedule(model, n, play, home, per):
    W = n - 1
    P = n // 2
    sched = [[None for _ in range(W)] for _ in range(P)]

    for w in range(W):
        for p in range(P):

            teams = [t for t in range(n)
                     if model.evaluate(per[(t,w,p)], model_completion=True)]

            if len(teams) != 2:
                sched[p][w] = [None, None]
                continue

            a, b = teams
            if model.evaluate(home[(a,b,w)], model_completion=True):
                sched[p][w] = [a, b]
            else:
                sched[p][w] = [b, a]

    return sched

def add_hard_constraints(s, n, play, home, per):
    W = n - 1
    P = n // 2

    for i in range(n):
        for j in range(i+1, n):
            s.add(exactly(1,
                [play[(i,j,w)] for w in range(W)] +
                [play[(j,i,w)] for w in range(W)]
            ))

    for i in range(n):
        for w in range(W):
            s.add(exactly(1,
                [play[(i,j,w)] for j in range(n) if j!=i] +
                [play[(j,i,w)] for j in range(n) if j!=i]
            ))

    for i in range(n):
        for w in range(W):
            s.add(exactly(1, [per[(i,w,p)] for p in range(P)]))

    for w in range(W):
        for p in range(P):
            s.add(exactly(2, [per[(i,w,p)] for i in range(n)]))

def add_channeling_constraints(s, n, play, home, per):
    W = n - 1
    P = n // 2

    for i in range(n):
        for j in range(n):
            if i==j: continue
            for w in range(W):
                s.add(Implies(home[(i,j,w)], play[(i,j,w)]))
                s.add(Implies(play[(i,j,w)],
                              Or(home[(i,j,w)], home[(j,i,w)])))
                s.add(Implies(play[(i,j,w)],
                              Not(And(home[(i,j,w)], home[(j,i,w)]))))

                s.add(Implies(
                    play[(i,j,w)],
                    Or([And(per[(i,w,p)], per[(j,w,p)]) for p in range(P)])
                ))

def add_implied_constraints(s, n, play, home, per):
    W = n - 1

    for i in range(n):
        for j in range(i):
            for w in range(W):
                s.add(Implies(home[(j,i,w)], play[(j,i,w)]))

    for i in range(n):
        for w in range(W):
            matches = [play[(i,j,w)] for j in range(n) if j!=i] + \
                      [play[(j,i,w)] for j in range(n) if j!=i]
            for a,b in zip(matches, matches[1:]):
                s.add(Or(Not(a), Not(b)))

    for i in range(n):
        for j in range(n):
            if i==j: continue
            for w in range(W):
                for p in range(n//2):
                    s.add(Implies(
                        And(per[(i,w,p)], per[(j,w,p)]),
                        Or(play[(i,j,w)], play[(j,i,w)])
                    ))

def add_symmetry_constraints(s, n, play, home):
    s.add(play[(0,1,0)])
    s.add(home[(0,1,0)])
    for j in range(2, n):
        s.add(Not(play[(0,j,0)]))

#Home/away imabalance constraint for optimization

def add_imbalance_constraints(s, n, home, delta):
    W = n - 1

    for i in range(n):
        H = []
        A = []
        for j in range(n):
            if i==j: continue
            for w in range(W):
                H.append(home[(i,j,w)])
                A.append(home[(j,i,w)])

        s.add(PbLe([(v,1) for v in H] + [(v,-1) for v in A], delta))
        s.add(PbLe([(v,1) for v in A] + [(v,-1) for v in H], delta))

# Solver

def solve_opt_instance(n):
    ensure_folders()

    play, home, per = create_vars(n)

    low, high = 0, n-1
    best_model = None
    best_delta = None

    start = time.time()

    while low <= high:
        mid = (low + high)//2

        s = Solver()
        s.set("timeout", 300000)
        s.set("threads", 1)

        add_hard_constraints(s, n, play, home, per)
        add_channeling_constraints(s, n, play, home, per)
        add_implied_constraints(s, n, play, home, per)
        add_symmetry_constraints(s, n, play, home)

        add_imbalance_constraints(s, n, home, mid)

        res = s.check()
        if str(res) == "sat":
            best_model = s.model()
            best_delta = mid
            high = mid - 1
        else:
            low = mid + 1

        if time.time() - start > 300:
            break

    if best_model is None:
        write_json(f"res/SAT/{n}.json", 300, False, None, None)
        return

    sched = extract_schedule(best_model, n, play, home, per)
    elapsed = int(min(300, time.time() - start))
    optimal = (best_delta == low)

    write_json(f"res/SAT/{n}.json", elapsed, optimal, best_delta, sched)

if __name__ == "__main__":
    if len(sys.argv)==2 and sys.argv[1].isdigit():
        solve_opt_instance(int(sys.argv[1]))
    else:
        values = [4,6,8,10,12,14,16,18]
        print("Running batch optimization solver:", values)
        for n in values:
            print(f"Solving n={n} ...")
            solve_opt_instance(n)
            print(f"Saved res/SAT/{n}.json")
        print("Batch complete.")